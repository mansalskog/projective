<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
	<title>Projective Geometry</title>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script>
	 let d = [];
	 let timeZero;

	 function time() {
	     return (Date.now() - timeZero) / 1000;
         }

         function slideNumber() {
             return parseInt(window.location.hash.split('-')[1]) || 0;
         }

         function updateHash(slides) {
             return (event) => {
                 const margin = 10;
                 for (let k = 0; k < slides.length; k++) {
                     if (window.scrollY > slides[k].offsetTop + margin && (k + 1 >= slides.length || window.scrollY < slides[k + 1].offsetTop - margin)) {
                         if (slideNumber() != k) {
                             window.history.replaceState(null, null, '#slide-' + k);
                         }
                         break;
                     }
                 }
             };
         }

         function initSlides() {
             const slides = document.querySelectorAll('.slide');
             for (let k = 0; k < slides.length; k++) {
                 slides[k].id = 'slide-' + k;
                 const controls = document.createElement('footer');
                 controls.className = 'controls';
                 const back = document.createElement('a');
                 if (k > 0) {
                     back.href = '#slide-' + (k - 1);
                     // back.addEventListener('click', setSlide(k - 1));
                     back.textContent = 'back';
                 }
                 controls.appendChild(back);
                 const number = document.createElement('span');
                 number.textContent = k;
                 controls.appendChild(number);
                 const next = document.createElement('a');
                 if (k < slides.length - 1) {
                     next.href = '#slide-' + (k + 1);
                     // next.addEventListener('click', setSlide(k + 1));
                     next.textContent = 'next';
                 }
                 controls.appendChild(next);
                 slides[k].appendChild(controls);
             }

             window.addEventListener('scroll', updateHash(slides));

             const demos = document.querySelectorAll('.demo');
             for (let k = 0; k < demos.length; k++) {
                 // demos[k].rows = 20;
                 // demos[k].cols = 80;
                 // demos[k].autocomplete = 'off';
                 eval(demos[k].textContent);
             }
         }

         function initScenes(canvas, engine) {
             let scenes = [];
             for (let k = 0; k < d.length; k++) {
                 scenes[k] = d[k] ? d[k](canvas, engine) : null;
             }
             return scenes;
         }

         const RED = new BABYLON.Color3(0.9, 0.1, 0.1);
         const GREEN = new BABYLON.Color3(0.1, 0.9, 0.1);
         const BLUE = new BABYLON.Color3(0.1, 0.1, 0.9);

         function blankScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, 0, 0, BABYLON.Vector3.Zero());
             return scene;
         }

         function teapotScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             // scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 16, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const material = new BABYLON.StandardMaterial('material', scene);
             material.backFaceCulling = false;
             // material.indexOfRefraction = 2.4;
             // material.specularPower = 0.98;
             // material.diffuseColor = new BABYLON.Color3(0, 0, 0.5); // (0x41 / 0xFF, 0x69 / 0xFF, 0xE1 / 0xFF);
             // = material.specularColor
             // material.ambientColor = material.emissiveColor =
             let teapot = null;
             BABYLON.SceneLoader.ImportMesh('', './newell_teaset/', 'teapot.obj', scene, (meshes) => {
                 teapot = BABYLON.Mesh.MergeMeshes(meshes);
                 teapot.name = 'teapot';
                 teapot.material = material;
             });
             return scene;
         }

         function planeScene(canvas, engine) {
             const scene = new BABYLON.Scene();
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 8, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 4});
             plane.rotation.x = Math.PI / 2;
             plane.position.y += 1;
             const transparent = new BABYLON.StandardMaterial('transparent', scene);
             transparent.alpha = 0.6;
             transparent.backFaceCulling = false;
             // transparent.wireframe = true;
             plane.material = transparent;
             const red = new BABYLON.StandardMaterial('red', scene);
             red.diffuseColor = RED;
             const green = new BABYLON.StandardMaterial('green', scene);
             green.diffuseColor = GREEN;
             const blue = new BABYLON.StandardMaterial('blue', scene);
             blue.diffuseColor = BLUE;
             return scene;
         }

         function ellipsePoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a * Math.cos(t);
                 let z = b * Math.sin(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             path.push(path[0]);
             return path;
         }

         function parabolaPoints(a) {
             let path = [];
             for (let t = -100; t < 100; t += 1 / 8) {
                 let x = 2 * a * t;
                 let z = a * t * t;
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function hyperbolaPoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a / Math.cos(t);
                 let z = b * Math.tan(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function createDoubleCone(h, r, s) {
             let cones = [BABYLON.MeshBuilder.CreateCylinder('cone0', {height: h, diameterTop: r, diameterBottom: 0}, s),
                          BABYLON.MeshBuilder.CreateCylinder('cone1', {height: h, diameterTop: r, diameterBottom: 0}, s)];
             cones[0].position.y += h / 2;
             cones[1].position.y -= h / 2;
             cones[1].rotation.x = Math.PI;
             return BABYLON.Mesh.MergeMeshes(cones);
         }

         function doRender() {
             canvas = document.getElementById('canvas');
             canvas.height = canvas.width = Math.floor(window.innerWidth / 4);

             const antialias = false;
             engine = new BABYLON.Engine(canvas, antialias);

             const scenes = initScenes(canvas, engine);
             const blank = blankScene(canvas, engine);

             window.addEventListener('resize', () => {
                 engine.resize();
             });

             timeZero = Date.now();
             engine.runRenderLoop(() => {
                 const k = slideNumber();
                 if (scenes[k]) {
                     scenes[k].render();
                 } else {
                     blank.render();
                 }
             });
         }

         function main() {
             initSlides();
             doRender();
         }
         window.addEventListener('load', main);
        </script>
        <style>
         body {
             margin: 0;
             padding: 0;
         }
         #canvas {
             position: fixed;
             right: 5vw;
             top: 10vh;
         }
         .slide {
             width: 60vw;
             height: 90vh;
             position: relative;
             padding: 2.5vw;
         }
         .controls {
             position: absolute;
             bottom: 5vw;
             left: 2.5vw;
             display: flex;
             justify-content: center;
             background-color: grey;
             border-radius: 5px;
         }
         .controls > * {
             flex: 1;
             margin: 1em;
             width: 2em;
             color: inherit;
             text-align: center;
             text-decoration: none;
         }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <section class="slide">
            <h1>Projective Geometry</h1>
            <p>
            </p>
            <pre class="demo">
d[0] = (c, e) => {
    const s = teapotScene(c, e);
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Linear Transformations</h2>
            <p>
                Using matrices we can for example rotate, \[
                B = \begin{pmatrix}
                \cos t & 0 & \sin t \\
                0 & 1 & 0 \\
                -\sin t & 0 & \cos t
                \end{pmatrix}
                \] and scale, \[
                A = \begin{pmatrix}
                0.75 + 0.25 \sin t & 0 & 0 \\
                0 & 0.75 + 0.25 \sin t & 0 \\
                0 & 0 & 0.75 + 0.25 \sin t
                \end{pmatrix}
                \] an object by multiplying each of its vertices with the matrix \(AB\).
            </p>
            <pre class="demo">
d[1] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        A = BABYLON.Matrix.FromValues(
            0.75 + 0.25 * Math.sin(time()), 0, 0, 0,
            0, 0.75 + 0.25 * Math.sin(time()), 0, 0,
            0, 0, 0.75 + 0.25 * Math.sin(time()), 0,
            0, 0, 0, 1
        ).transpose();
        B = BABYLON.Matrix.FromValues(
            Math.cos(time()), 0, Math.sin(time()), 0,
            0, 1, 0, 0,
            -Math.sin(time()), 0, Math.cos(time()), 0,
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(B.multiply(A), false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Affine transformations</h2>
            <p>
                By adding an extra coordinate to the vertices, \[
                p = \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \quad \Longrightarrow \quad p_H = \begin{bmatrix}
                x \\ y \\ z \\ 1
                \end{bmatrix},
                \] we can also obtain translations, for example by \[
                C = \begin{bmatrix}
                1 & 0 & 0 & 2 \cos t \\
                1 & 0 & 0 & 0 \\
                1 & 0 & 0 & 2 \sin t \\
                0 & 0 & 0 & 1
                \end{bmatrix}.
                \]
                How can we interpret this association of \(p\) with \(p_H\) geometrically?
            </p>
            <pre class="demo">
d[2] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        C = BABYLON.Matrix.FromValues(
            1, 0, 0, 2 * Math.cos(time()),
            0, 1, 0, 0,
            0, 0, 1, 2 * Math.sin(time()),
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(C, false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Homogeneous coordinates</h2>
            <p>
                We identify a line on the form \[
                p_H = \left\{ \begin{pmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{pmatrix} : \lambda \in \mathbf{R} \right\},
                \] with any representative \[
                p_H = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \quad \text{for a fixed } \lambda \neq 0.
                \]
            </p>
            <p>
                These representatives are called the <em>homogeneous coordinates</em> of the point \[
                p = \begin{pmatrix}
                x \\ y
                \end{pmatrix}
                \] in the two dimensional plane.
                Each 2D point is thus represented by a one-dimensional subspace (a line) in 3D.
                In a similar manner, each 3D point can be represented by a one-dimensional subspace of 4D space.
            </p>
            <script>
             d[3] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 s.registerBeforeRender(() => {
                     p.position.x = 2 * Math.cos(time() / 2);
                     p.position.y = 1;
                     p.position.z = Math.sin(time() / 2);
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <!--
        <section class="slide">
            <p>
                Geometrically, this means projecting the lines onto the plane parallel to the \(xy\) plane with \(z = 1\).
            </p>
            <script class="demo">
             d[4] = (c, e) => {
                 let s = teapotScene(c, e);
                 let p = BABYLON.MeshBuilder.CreatePlane('p', {size: 5}, s);
                 // p.rotation.x = Math.PI / 2;
                 p.position.z += 3;
                 p.position.y += 1;
                 const material = new BABYLON.StandardMaterial('material', s);
                 material.alpha = 0.6;
                 material.backFaceCulling = false;
                 p.material = material;
                 T = BABYLON.Matrix.FromValues(
                     1, 0, 0, 0,
                     0, 1, 0, 0,
                     0, 0, 1, -2,
                     0, 0, 0, 1
                 ).transpose();
                 P = BABYLON.Matrix.FromValues(
                     1, 0, 0, 0,
                     0, 1, 0, 0,
                     0, 0, 1, 0,
                     0, 1, 0, 1
                 ).transpose();
                 s.registerBeforeRender(() => {
                     let camera = s.getCameraByName('camera');
                     camera.alpha = time();
                     let m = s.getMeshByName('teapot');
                     if (m) {
                         m.setPivotMatrix(T.multiply(P), false);
                     }
                 });
                 return s;
             };
            </script>
        </section>
        -->
        <section class="slide">
            <h2>Points at infinity</h2>
            <p>
                We see that the 2D point \(p\) is given by the intersection between \(p_H\) and the plane \[
                p_H \cdot \begin{pmatrix} 0 & 0 & 1 \end{pmatrix} = 1,
                \] but what happends for \[
                p_H = \begin{bmatrix}
                \lambda x \\ \lambda y \\ 0
                \end{bmatrix}?
                \]
                These lines can be seen as representing <em>points at infinity</em>, in the direction given by \(x\) and \(y\).
            </p>
            <p>
                In one dimension there is only one point at infinity, commonly denoted \(\infty\).
                In two dimensions there is <em>line at infinity</em> and in three dimensions a <em>plane at infinity</em>.
            </p>
            <script>
             d[4] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [new BABYLON.Vector3(0, 0, -1.5), new BABYLON.Vector3(0, 0, 1.5)]}, s);
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = 1 / (1 - Math.abs(Math.sin(time())));
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.normalizeToNew().scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representation of lines in 2D</h2>
            <p>
                This representation of points in 2D also gives a simple representation of lines in 2D:
                The line containing points with homogeneous coordinates \(p_H\) and \(q_H\) is has homogeneous coordinates given by the two-dimensional subspace \(l_H\),
                containing both \(p_H\) and \(q_H\).
            </p>
            <p>
                The normal vector of this plane in 3D is easily computed as the scalar product \[
                p_H \times q_H = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \times \begin{bmatrix}
                \mu z \\ \mu w \\ \mu
                \end{bmatrix} = \begin{bmatrix}
                \lambda \mu (y-w) \\
                \lambda \mu (z-x) \\
                \lambda \mu (xw-yz)
                \end{bmatrix} = l_H,
                \] where we identify any normal vector of the plane with the plane itself.
            </p>
            <p>
                Finding the point where two lines \(l\) and \(m\) intersect simply amounts to finding the intersection between the planes \(l_H\) and \(m_H\),
                which can be done with the cross product of the normal vectors, \[
                p_H = l_H \times m_H.
                \]
                The fact that points and lines are essentially interchangeable in 2D is called <em>duality</em>.
            </p>
            <p>
                What happens if the two lines are parallel? For example, consider \[
                l_H = \begin{bmatrix}
                1 \\ 2 \\ 3
                \end{bmatrix} \quad \text{and} \quad m_H = \begin{bmatrix}
                1 \\ 2 \\ 5
                \end{bmatrix} \quad \Longrightarrow \quad p_H = l_H \times m_H = \begin{bmatrix}
                4 \\ -2 \\ 0
                \end{bmatrix}.
                \]
                In the interpretation of projective geometry, the \(l\) and \(m\) meet some point at infinity \(p\).
                In fact, any line parallel to \(l\) will meet it at \(p\).
            </p>
            <p>
                What if the lines are coincident (i.e. the same line)?
                Then the cross product of the homogeneous coordinates is zero.
                The converse is also true.
            </p>
            <script>
             d[5] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let q = BABYLON.MeshBuilder.CreateSphere('q', {diameter: 0.2}, s);
                 q.material = s.getMaterialByName('blue');
                 q.position.x = 1.5;
                 q.position.y = 1;
                 q.position.z = 1;
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 let n = BABYLON.MeshBuilder.CreateLines('n', {points: [q.position.scale(-0.5), q.position.scale(1.5)]}, s);
                 n.color = BLUE;
                 // let plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 3});
                 // plane.rotation.x = Math.PI / 2;
                 // plane.position.z += 1;
                 // plane.material = s.getMaterialByName('transparent');
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = Math.sin(time());
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                     let d = q.position.subtract(p.position).scale(0.5);
                     m = BABYLON.MeshBuilder.CreateLines('m', {points: [p.position.subtract(d), q.position.add(d)], instance: m}, s);
                     /* let normal = p.position.cross(q.position);
                     let T = BABYLON.Matrix.FromValues(
                         q.position.x, normal.x, p.position.x, 0,
                         q.position.y, normal.y, p.position.y, 0,
                         q.position.z, normal.z, p.position.z, 0,
                         0, 0, 0, 1
                     ).transpose();
                     plane.setPivotMatrix(T, false); */
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representing planes in 3D</h2>
            <p>
                The situation with points and lines in 2D is analogous to points and planes in 3D, as both objects have three degrees of freedom.
                The Cartesian equation for the plane is \[
                \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \in \pi \quad \Longleftrightarrow \quad \begin{pmatrix}
                a \\ b \\ c
                \end{pmatrix} \cdot \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} = d,
                \] where \(\begin{pmatrix} a & b & c \end{pmatrix}^T\) is a normal vector and \(d\) a constand determining "how far the plane is from the origin".
            </p>
            <p>
                In homogeneous coordinates this can be expressed as \begin{equation}
                \tag{*} \label{star}
                p_H \in \pi_H \quad \Longleftrightarrow \quad p_H \cdot \pi_H = 0.
                \end{equation}
            </p>
            <p>
                Problem: when applying an affine transformation \(A\) to the space, planes are not transformed as expected.
                The same is true for lines in 2D.
                Let \(p_H' = A p_H\) and \(\pi_H' = A \pi_H\). Then the equation becomes \[
                0 = p_H' \cdot \pi_H' = (A p_H) \cdot (A \pi_H) = (A p_H)^T (A \pi_H) = p_H A^T A \pi_H,
                \] but this is not the same as \eqref{star}!
                The solution is to transform planes by the inverse of the transpose of \(A\), so that \(\pi_H' = (A^T)^{-1}\), and the equation becomes \[
                0 = p_H' \cdot \pi_H' = (A p_H) \cdot ((A^T)^{-1} \pi_H) = (A p_H)^T ((A^T)^{-1} \pi_H) = p_H A^T (A^T)^{-1} \pi_H = p_H \cdot \pi_H.
                \]
                This also applies when transforming lines in 2D, as both \(l_H\) and \(\pi_H\) are essentially normal vectors of the line or plane they represent.
            </p>
        </section>
        <section class="slide">
            <h2>Representing planes in 3D, continued</h2>
            <p>
                We know that a plane in 3D is characterized by three points.
                To find the plane which contains three given points \(p_H, q_H, r_H\) we need to find a solution \(\pi_H\) to the system \[
                \begin{cases}
                p_H \cdot \pi_H = 0, \\
                q_H \cdot \pi_H = 0, \\
                r_H \cdot \pi_H = 0,
                \end{cases}
                \] which is equvalent to \[
                \begin{bmatrix}
                - & p_H^T & - \\
                - & q_H^T & - \\
                - & r_H^T & -
                \end{bmatrix} \pi_H = 0,
                \] meaning that \(\pi_H\) is given by (an arbitrary vector in) the null space of the matrix above.
            </p>
            <p>
                Because of duality, we can easily find the point of intersection of three planes \(\pi_H, \rho_H, \sigma_H\) in the null space of \[
                \begin{bmatrix}
                - & \pi_H^T & - \\
                - & \rho_H^T & - \\
                - & \sigma_H^T & -
                \end{bmatrix}.
                \]
            </p>
        </section>
        <section class="slide">
            <h2>Representing lines in 3D</h2>
            <p>
                In 3D lines have more degrees of freedom than a point has.
                Therefore their representation becomes more complicated, and there are various different methods of representing a line,
                one of which is the <em>Pl√ºcker matrix</em>.
                To represent a line between \(p_H\) and \(q_H\), the matrix \[
                L_H = p_H q_H^T - q_H p_H^T
                \] is used.
                We see that this is an antisymmetric matrix, \[
                L_H^T = (p_H q_H^T)^T - (q_H p_H^T)^T = q_H p_H^T - p_H q_H^T = -L_H.
                \]
            </p>
            <p>
                This representation gives a number of nice formulas:
                \begin{align*}
                p_H \in L_H \quad \Longleftrightarrow L_H \pi_H = 0,
                L_H \subset \pi_H \quad \Longleftrightarrow L_H \pi_H = 0,
                \end{align*}
            </p>
        </section>
        <section class="slide">
            <h2>Circles, ellipses, parabolas and hyperbolas</h2>

            <!--
            <script>
             d[7] = (c, e) => {
                 let s = planeScene(c, e);
                 let cone = createDoubleCone(3, 3, s);
                 let material = new BABYLON.StandardMaterial('material', s);
                 material.diffuseColor = RED;
                 material.alpha = 0.6;
                 cone.material = material;
                 cone.material = material;
                 let circle = BABYLON.MeshBuilder.CreateLines('circle', {points: ellipsePoints(0.5, 0.5), updatable: true}, s);
                 circle.color = GREEN;
                 s.registerBeforeRender(() => {
                     cone.rotation.x = time() / 2;
                 });
                 return s;
             }
            </script>
            -->
        </section>
        <section class="slide">
            <h2>Computational advantages of projective geometry</h2>
            <p>
                The extra coordinate means we must store more data, but it allows us to postpone divisions as long as possible,
                as this can be accomplished by simply multiplying the third coordinate.
                This in turn gives improved precision, and it's even possible to use integer arithmetic in many places.
            </p>
            <p>
                Similarily, points at infinity allow us to handle special cases without any extra code.
                This also speeds up computation slightly since less branches are needed, which is one of the more expensive operations in modern computers.
            </p>
        </section>
    </body>
</html>
