<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
	<title>Projective Geometry</title>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script>
	 let d = [];
	 let timeZero;

	 function time() {
	     return (Date.now() - timeZero) / 1000;
         }

         function slideNumber() {
             return parseInt(window.location.hash.split('-')[1]) || 0;
         }

         function updateHash(slides) {
             return (event) => {
                 const margin = 10;
                 for (let k = 0; k < slides.length; k++) {
                     if (window.scrollY > slides[k].offsetTop + margin && (k + 1 >= slides.length || window.scrollY < slides[k + 1].offsetTop - margin)) {
                         if (slideNumber() != k) {
                             window.history.replaceState(null, null, '#slide-' + k);
                         }
                         break;
                     }
                 }
             };
         }

         function initSlides() {
             const slides = document.querySelectorAll('.slide');
             for (let k = 0; k < slides.length; k++) {
                 slides[k].id = 'slide-' + k;
                 const controls = document.createElement('footer');
                 controls.className = 'controls';
                 const back = document.createElement('a');
                 if (k > 0) {
                     back.href = '#slide-' + (k - 1);
                     // back.addEventListener('click', setSlide(k - 1));
                     back.textContent = 'back';
                 }
                 controls.appendChild(back);
                 const number = document.createElement('span');
                 number.textContent = k;
                 controls.appendChild(number);
                 const next = document.createElement('a');
                 if (k < slides.length - 1) {
                     next.href = '#slide-' + (k + 1);
                     // next.addEventListener('click', setSlide(k + 1));
                     next.textContent = 'next';
                 }
                 controls.appendChild(next);
                 slides[k].appendChild(controls);
             }

             window.addEventListener('scroll', updateHash(slides));

             const demos = document.querySelectorAll('.demo');
             for (let k = 0; k < demos.length; k++) {
                 // demos[k].rows = 20;
                 // demos[k].cols = 80;
                 // demos[k].autocomplete = 'off';
                 eval(demos[k].textContent);
             }
         }

         function initScenes(canvas, engine) {
             let scenes = [];
             for (let k = 0; k < d.length; k++) {
                 scenes[k] = d[k] ? d[k](canvas, engine) : null;
             }
             return scenes;
         }

         const RED = new BABYLON.Color3(0.9, 0.1, 0.1);
         const GREEN = new BABYLON.Color3(0.1, 0.9, 0.1);
         const BLUE = new BABYLON.Color3(0.1, 0.1, 0.9);
         const BLACK = new BABYLON.Color3(0, 0, 0);

         function blankScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, 0, 0, BABYLON.Vector3.Zero());
             return scene;
         }

         function loadTeapot(scene, callback) {
             BABYLON.SceneLoader.ImportMesh('', './newell_teaset/', 'teapot.obj', scene, (meshes) => {
                 callback(BABYLON.Mesh.MergeMeshes(meshes));
             });
         }

         function teapotScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 16, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const material = new BABYLON.StandardMaterial('material', scene);
             material.backFaceCulling = false;
             // material.indexOfRefraction = 2.4;
             // material.specularPower = 0.98;
             // material.diffuseColor = new BABYLON.Color3(0, 0, 0.5); // (0x41 / 0xFF, 0x69 / 0xFF, 0xE1 / 0xFF);
             // = material.specularColor
             // material.ambientColor = material.emissiveColor =
             let teapot = null;
             loadTeapot(scene, t => {
                 t.name = 'teapot';
                 t.material = material;
                 teapot = t;
             });
             return scene;
         }

         function planeScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 8, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 4});
             plane.rotation.x = Math.PI / 2;
             plane.position.y += 1;
             const transparent = new BABYLON.StandardMaterial('transparent', scene);
             transparent.alpha = 0.6;
             transparent.backFaceCulling = false;
             // transparent.wireframe = true;
             plane.material = transparent;
             const red = new BABYLON.StandardMaterial('red', scene);
             red.diffuseColor = RED;
             const green = new BABYLON.StandardMaterial('green', scene);
             green.diffuseColor = GREEN;
             const blue = new BABYLON.StandardMaterial('blue', scene);
             blue.diffuseColor = BLUE;
             const black = new BABYLON.StandardMaterial('black', scene);
             black.diffuseColor = BLACK;
             return scene;
         }

         function ellipsePoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a * Math.cos(t);
                 let z = b * Math.sin(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             path.push(path[0]);
             return path;
         }

         function parabolaPoints(a) {
             let path = [];
             for (let t = -100; t < 100; t += 1 / 8) {
                 let x = -a * t * t;
                 let z = 2 * a * t;
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function hyperbolaPoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a / Math.cos(t);
                 let z = b * Math.tan(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function createDoubleCone(h, r, s) {
             let cones = [BABYLON.MeshBuilder.CreateCylinder('cone0', {height: h, diameterTop: r, diameterBottom: 0}, s),
                          BABYLON.MeshBuilder.CreateCylinder('cone1', {height: h, diameterTop: r, diameterBottom: 0}, s)];
             cones[0].position.y += h / 2;
             cones[1].position.y -= h / 2;
             cones[1].rotation.x = Math.PI;
             return BABYLON.Mesh.MergeMeshes(cones);
         }

         function projectMesh(mesh) {
             let pos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
             let matrix = mesh.getWorldMatrix();
             let path = [];
             for (let k = 0; k < pos.length; k += 3) {
                 let vertex = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(pos[k], pos[k + 1], pos[k + 2]), matrix);
                 if (Math.abs(vertex.z) > 0) {
                     // vertex.x *= 3 / Math.abs(vertex.z);
                     // vertex.y *= 3 / Math.abs(vertex.z);
                 }
                 vertex.z = 1;
                 path.push(vertex);
             }
             return path;
         }

         function transformBadNormals(mesh, matrix) {
             let normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
             for (let k = 0; k < normals.length; k += 3) {
                 let n = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(normals[k], normals[k + 1], normals[k + 2]), matrix);
                 normals[k] = n.x;
                 normals[k + 1] = n.y;
                 normals[k + 2] = n.z;
             }
             mesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
             let pos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
             for (let k = 0; k < pos.length; k += 3) {
                 let p = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(pos[k], pos[k + 1], pos[k + 2]), matrix);
                 pos[k] = p.x;
                 pos[k + 1] = p.y;
                 pos[k + 2] = p.z;
             }
             mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, pos);
         }

         function transformGoodNormals(mesh, matrix) {
             let normals = mesh.getVerticesData(BABYLON.VertexBuffer.NormalKind);
             let inv = new BABYLON.Matrix();
             matrix.invertToRef(inv);
             for (let k = 0; k < normals.length; k += 3) {
                 let n = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(normals[k], normals[k + 1], normals[k + 2]), inv.transpose());
                 normals[k] = n.x;
                 normals[k + 1] = n.y;
                 normals[k + 2] = n.z;
             }
             mesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
             let pos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
             for (let k = 0; k < pos.length; k += 3) {
                 let p = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(pos[k], pos[k + 1], pos[k + 2]), matrix);
                 pos[k] = p.x;
                 pos[k + 1] = p.y;
                 pos[k + 2] = p.z;
             }
             mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, pos);
         }

         function doRender() {
             canvas = document.getElementById('canvas');
             canvas.height = canvas.width = Math.floor(window.innerWidth / 3);

             const antialias = false;
             engine = new BABYLON.Engine(canvas, antialias);

             const scenes = initScenes(canvas, engine);
             const blank = blankScene(canvas, engine);

             window.addEventListener('resize', () => {
                 engine.resize();
             });

             timeZero = Date.now();
             engine.runRenderLoop(() => {
                 const k = slideNumber();
                 if (scenes[k]) {
                     scenes[k].render();
                 } else {
                     blank.render();
                 }
             });
         }

         function main() {
             initSlides();
             doRender();
         }
         window.addEventListener('load', main);
        </script>
        <link rel="preconnect" href="https://fonts.gstatic.com">
        <link href="https://fonts.googleapis.com/css2?family=PT+Sans&family=PT+Serif:wght@700&display=swap" rel="stylesheet">
        <style>
         body {
             margin: 0;
             padding: 0;
             font-family: 'PT Sans', sans-serif;
         }
         h1, h2, h3 {
             font-family: 'PT Serif', serif;
         }
         h1 {
             font-size: 50pt;
             text-align: center;
         }
         h2 {
             font-size: 25pt;
         }
         h3 {
             font-size: 20pt;
             text-align: center;
         }
         #canvas {
             position: fixed;
             right: 5vw;
             top: 10vh;
             /* border: 1px solid black;
                border-radius: 5px; */
         }
         .slide {
             width: 60vw;
             height: 90vh;
             position: relative;
             padding: 2.5vw;
         }
         .slide:first-child {
             width: 95vw;
         }
         .controls {
             position: absolute;
             bottom: 5vw;
             left: 2.5vw;
             display: flex;
             justify-content: center;
             background-color: grey;
             border-radius: 5px;
         }
         .controls > * {
             flex: 1;
             margin: 1em;
             width: 2em;
             color: inherit;
             text-align: center;
             text-decoration: none;
         }
        </style>
    </head>
    <body>
        <section class="slide">
            <h1>Projective Geometry and Computer Graphics</h1>
            <h3>Måns Alskog</h3>
            <h3>November 2020</h3>
            <!--
                 <script>
                 d[0] = (c, e) => {
                 const s = new BABYLON.Scene(e);
                 s.clearColor = new BABYLON.Color4(0, 0, 0, 0);
                 const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 16, new BABYLON.Vector3(-4, 0, 0), s);
                 const l = new BABYLON.DirectionalLight('light', new BABYLON.Vector3(0, -1, 0), s);
                 l.intensity = 0.3;
                 const plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 0.5});
                 const m = new BABYLON.StandardMaterial('m', s);
                 m.diffuseColor = GREEN;
                 m.backFaceCulling = false;
                 plane.material = m;
                 plane.rotation.x = Math.PI / 2;
                 plane.position.y += 1;
                 for (let z = -20; z < 20; z++) {
                 for (let x = -20; x < 5; x++) {
                 let inst = plane.createInstance('p' + x + 'p' + z);
                 inst.position.x = x;
                 inst.position.z = x % 0.5 + z;
                 }
                 }
                 let parabola = BABYLON.MeshBuilder.CreateLines('parabola', {points: parabolaPoints(0.5), updatable: true}, s);
                 parabola.color = RED;
                 s.registerBeforeRender(() => {
                 camera.beta = Math.PI * 3 / 8 * (0.5 + 0.5 * Math.sin(time()));
                 //parabola = BABYLON.MeshBuilder.CreateLines('parabola', {points: parabolaPoints(Math.abs(Math.sin(time()))), instance: parabola}, s);
                 });
                 return s;
                 };
                 </script>
            -->
        </section>
        <canvas id="canvas"></canvas>
        <section class="slide">
            <h2>Linear Transformations</h2>
            <p>
                Using matrices we can for example rotate, \[
                B = \begin{pmatrix}
                \cos t & 0 & \sin t \\
                0 & 1 & 0 \\
                -\sin t & 0 & \cos t
                \end{pmatrix}
                \] and scale, \[
                A = \begin{pmatrix}
                0.75 + 0.25 \sin t & 0 & 0 \\
                0 & 0.75 + 0.25 \sin t & 0 \\
                0 & 0 & 0.75 + 0.25 \sin t
                \end{pmatrix}
                \] an object by multiplying each of its vertices with the matrix \(AB\).
            </p>
            <script>
             d[1] = (c, e) => {
                 let s = teapotScene(c, e);
                 s.registerBeforeRender(() => {
                     A = BABYLON.Matrix.FromValues(
                         0.75 + 0.25 * Math.sin(time()), 0, 0, 0,
                         0, 0.75 + 0.25 * Math.sin(time()), 0, 0,
                         0, 0, 0.75 + 0.25 * Math.sin(time()), 0,
                         0, 0, 0, 1
                     ).transpose();
                     B = BABYLON.Matrix.FromValues(
                         Math.cos(time()), 0, Math.sin(time()), 0,
                         0, 1, 0, 0,
                         -Math.sin(time()), 0, Math.cos(time()), 0,
                         0, 0, 0, 1
                     ).transpose();
                     let m = s.getMeshByName('teapot');
                     if (m) {
                         m.setPivotMatrix(A.multiply(B), false);
                     }
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Affine transformations</h2>
            <p>
                By adding an extra coordinate to the vertices, \[
                p = \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \quad \Longrightarrow \quad \tilde{p} = \begin{bmatrix}
                x \\ y \\ z \\ 1
                \end{bmatrix},
                \] we can also obtain translations, for example by \[
                C = \begin{bmatrix}
                1 & 0 & 0 & 2 \cos t \\
                1 & 0 & 0 & 0 \\
                1 & 0 & 0 & 2 \sin t \\
                0 & 0 & 0 & 1
                \end{bmatrix} \quad \Longrightarrow \quad C \tilde{p} = \begin{bmatrix}
                x + 2 \cos t \\ y \\ z + 2 \cos t \\ 1
                \end{bmatrix}
                \]
                How can we interpret this association of \(p\) with \(\tilde{p}\) geometrically?
            </p>
            <script>
             d[2] = (c, e) => {
                 let s = teapotScene(c, e);
                 s.registerBeforeRender(() => {
                     C = BABYLON.Matrix.FromValues(
                         1, 0, 0, 2 * Math.cos(time()),
                         0, 1, 0, 0,
                         0, 0, 1, 2 * Math.sin(time()),
                         0, 0, 0, 1
                     ).transpose();
                     let m = s.getMeshByName('teapot');
                     if (m) {
                         m.setPivotMatrix(C, false);
                     }
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Homogeneous coordinates</h2>
            <p>
                We identify a line on the form \[
                \operatorname{span} \begin{pmatrix}
                x \\ y \\ 1
                \end{pmatrix} = \left\{ \begin{pmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{pmatrix} : \lambda \in \mathbf{R} \right\},
                \] with any representative \[
                \tilde{p} = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \quad \text{for a fixed } \lambda \neq 0.
                \]
            </p>
            <p>
                These representatives are called the <em>homogeneous coordinates</em> of the point \[
                p = \begin{pmatrix}
                x \\ y
                \end{pmatrix}
                \] in the two dimensional plane.
                Each 2D point is thus represented by a one-dimensional subspace (a line) in 3D.
                In a similar manner, each 3D point can be represented by a one-dimensional subspace of 4D space.
            </p>
            <p>
                <strong>Example:</strong> \[
                \begin{bmatrix}
                0.5 \\ 0.2 \\ 1
                \end{bmatrix} = \begin{bmatrix}
                5 \\ 2 \\ 10
                \end{bmatrix} = \begin{bmatrix}
                0.44 \dots \\ 0.17 \dots \\ 0.88 \dots
                \end{bmatrix}
                \]
            </p>
            <script>
             d[3] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 s.registerBeforeRender(() => {
                     p.position.x = 2 * Math.cos(time() / 2);
                     p.position.y = 1;
                     p.position.z = Math.sin(time() / 2);
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Points at infinity</h2>
            <p>
                We see that the 2D point \(p\) is given by the intersection between \(\tilde{p}\) and the plane parallel
                to the \(xy\) plane with \(z = 1\), called the <em>viewing plane</em>.
                What happens for \[
                \tilde{p} = \begin{bmatrix}
                x \\ y \\ 0
                \end{bmatrix}?
                \]
                These lines can be seen as representing <em>points at infinity</em>, in the direction given by \(x\) and \(y\).
            </p>
            <p>
                In one dimension there is only one point at infinity, commonly denoted \(\infty\).
                In two dimensions there is <em>line at infinity</em> and in three dimensions a <em>plane at infinity</em>.
            </p>
            <p>
                <strong>Note:</strong> sometimes these points are interpreted as vectors, as \[
                \begin{bmatrix}
                x \\ y \\ 1
                \end{bmatrix} - \begin{bmatrix}
                z \\ w \\ 1
                \end{bmatrix} = \begin{bmatrix}
                x - z \\ y - w \\ 0
                \end{bmatrix}
                \] and \[
                \begin{bmatrix}
                x \\ y \\ 1
                \end{bmatrix} + \begin{bmatrix}
                \Delta x \\ \Delta y \\ 0
                \end{bmatrix} = \begin{bmatrix}
                x + \Delta x \\ y + \Delta y \\ 1
                \end{bmatrix},
                \]
                however this is not really supported by the theory
                and can result in errors when combined with other transformations.
            </p>
            <script>
             d[4] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [new BABYLON.Vector3(0, 0, -1.5), new BABYLON.Vector3(0, 0, 1.5)]}, s);
                 m.color = BLACK;
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = 1 / (1 - Math.abs(Math.sin(time())));
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.normalizeToNew().scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representation of lines in 2D</h2>
            <p>
                This representation of points in 2D also gives a simple representation of lines in 2D:
                The line containing points with homogeneous coordinates \(\tilde{p}\) and \(\tilde{q}\) is has homogeneous coordinates given by
                the two-dimensional subspace with normal vector \(\tilde{l}\),
                containing both \(\tilde{p}\) and \(\tilde{q}\).
            </p>
            <p>
                The normal vector of this plane in 3D is easily computed as the scalar product \[
                \tilde{p} \times \tilde{q} = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \times \begin{bmatrix}
                \mu z \\ \mu w \\ \mu
                \end{bmatrix} = \begin{bmatrix}
                \lambda \mu (y-w) \\
                \lambda \mu (z-x) \\
                \lambda \mu (xw-yz)
                \end{bmatrix} = \tilde{l},
                \] where we identify any normal vector of the plane with the plane itself.
            </p>
            <p>
                <strong>Remark:</strong> if the two points are the same, then \(\tilde{p} = \lambda \tilde{q}\) for some \(\lambda\),
                and \(\tilde{p} \times \tilde{q} = 0\), signifying the fact that there are infinitely many lines containing \(p\) and \(q\).
            </p>
            <script>
             d[5] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let q = BABYLON.MeshBuilder.CreateSphere('q', {diameter: 0.2}, s);
                 q.material = s.getMaterialByName('blue');
                 q.position.x = 1.5;
                 q.position.y = 1;
                 q.position.z = 1;
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 m.color = BLACK;
                 let n = BABYLON.MeshBuilder.CreateLines('n', {points: [q.position.scale(-0.5), q.position.scale(1.5)]}, s);
                 n.color = BLUE;
                 // let plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 3});
                 // plane.rotation.x = Math.PI / 2;
                 // plane.position.z += 1;
                 // plane.material = s.getMaterialByName('transparent');
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = Math.sin(time());
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                     let d = q.position.subtract(p.position).scale(0.5);
                     m = BABYLON.MeshBuilder.CreateLines('m', {points: [p.position.subtract(d), q.position.add(d)], instance: m}, s);
                     /* let normal = p.position.cross(q.position);
                        let T = BABYLON.Matrix.FromValues(
                        q.position.x, normal.x, p.position.x, 0,
                        q.position.y, normal.y, p.position.y, 0,
                        q.position.z, normal.z, p.position.z, 0,
                        0, 0, 0, 1
                        ).transpose();
                        plane.setPivotMatrix(T, false); */
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Intersection of lines in 2D</h2>
            <p>
                Finding the point where two lines \(l\) and \(m\) intersect simply amounts to finding the intersection between
                the planes with normal vectors \(\tilde{l}\) and \(\tilde{m}\), which can be done with the cross product, \[
                \tilde{p} = \tilde{l} \times \tilde{m}.
                \]
                The fact that points and lines are essentially interchangeable in 2D is called <em>duality</em>.
            </p>
            <p>
                What happens if the two lines are parallel? For example, consider \[
                \tilde{l} = \begin{bmatrix}
                1 \\ 2 \\ 3
                \end{bmatrix} \quad \text{and} \quad \tilde{m} = \begin{bmatrix}
                1 \\ 2 \\ 5
                \end{bmatrix} \quad \Longrightarrow \quad \tilde{p} = \tilde{l} \times \tilde{m} = \begin{bmatrix}
                4 \\ -2 \\ 0
                \end{bmatrix}.
                \]
                In the interpretation of projective geometry, \(l\) and \(m\) meet some point at infinity \(p\).
                In fact, any line parallel to \(l\) will meet it at \(p\).
            </p>
            <p>
                <strong>Remark</strong> If the lines are coincident (i.e. the same line),
                the cross product of the homogeneous coordinates is zero.
                The converse is also true.
            </p>
            <script>
                d[6] = (c, e) => {
                let s = planeScene(c, e);
                let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                o.material = s.getMaterialByName('red');
                let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                p.material = s.getMaterialByName('black');
                let l0 = new BABYLON.Vector3(1, 1, -2);
                let l1 = new BABYLON.Vector3(-2, 1, 0);
                let l = BABYLON.MeshBuilder.CreateLines('l', {points: [l0, l1], updatable: true}, s);
                l.color = GREEN;
                let lnorm = BABYLON.MeshBuilder.CreateLines('lnorm', {points: [l0, l1], updatable: true}, s);
                lnorm.color = GREEN;
                let n0 = new BABYLON.Vector3(2, 1, 2);
                let n1 = new BABYLON.Vector3(-2, 1, -2);
                let n = BABYLON.MeshBuilder.CreateLines('n', {points: [n0, n1]}, s);
                n.color = BLUE;
                let nn = n1.cross(n0);
                nn.normalize()
                let nnorm = BABYLON.MeshBuilder.CreateLines('norm', {points: [n0, n0.add(nn)]}, s);
                nnorm.color = BLUE;
                s.registerBeforeRender(() => {
                // s.getCameraByName('camera').alpha = time();
                l0.z = -2 * Math.sin(time());
                l = BABYLON.MeshBuilder.CreateLines('l', {points: [l0, l1], instance: l}, s);
                let ln = l1.cross(l0);
                ln.normalize();
                lnorm = BABYLON.MeshBuilder.CreateLines('lnorm', {points: [l1, l1.add(ln)], instance: lnorm}, s);
                p.position = nn.cross(ln);
                p.position.scaleInPlace(1 / p.position.y);
                });
                return s;
                };
            </script>
        </section>
        <section class="slide">
            <h2>Representing planes in 3D</h2>
            <p>
                The dual of points in 2D are lines, and analogously the dual of points in 3D are planes, as both points and planes have three degrees of freedom.
                The equation of the plane in Cartesian coordinates is \[
                \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \in \pi \quad \Longleftrightarrow \quad \begin{pmatrix}
                a \\ b \\ c
                \end{pmatrix} \cdot \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} = -d,
                \] where \(\begin{pmatrix} a & b & c \end{pmatrix}^T\) is a normal vector and \(d\) a constant determining how far the plane is from the origin,
                in units of the length of the normal vector.
            </p>
            <p>
                In homogeneous coordinates this can be expressed as \[
                p \in \pi \quad \Longleftrightarrow \quad \tilde{p} \cdot \tilde{\pi} = 0,
                \] where \[
                \tilde{p} = \begin{bmatrix}
                x \\ y \\ z \\ 1
                \end{bmatrix} \quad \text{and} \quad \tilde{\pi} = \begin{bmatrix}
                a \\ b \\ c \\ d
                \end{bmatrix}.
                \]
            </p>
        </section>
        <section class="slide">
            <h2>Trnasforming normal vectors</h2>
            <p>
                When applying an affine transformation \(A\) to the space, planes are not transformed as expected.
                The same is true for lines in 2D.
            </p>
            <p>
                Let \(\tilde{p}' = A \tilde{p}\) and \(\tilde{\pi}' = A \tilde{\pi}\). Then the equation of the transformed plane becomes \[
                0 = \tilde{p}' \cdot \tilde{\pi}' = (A \tilde{p}) \cdot (A \tilde{\pi}) = (A \tilde{p})^T (A \tilde{\pi}) = \tilde{p} A^T A \tilde{\pi},
                \] but this is not the same plane as \[
                0 = \tilde{p} \cdot \tilde{\pi}.
                \]
                The solution is to transform planes by the inverse of the transpose of \(A\), so that \(\tilde{\pi}' = (A^T)^{-1} \tilde{\pi}\), and the equation becomes \[
                0 = \tilde{p}' \cdot \tilde{\pi}'
                = (A \tilde{p}) \cdot ((A^T)^{-1} \tilde{\pi})
                = (A \tilde{p})^T ((A^T)^{-1} \tilde{\pi})
                = \tilde{p} A^T (A^T)^{-1} \tilde{\pi}
                = \tilde{p} \cdot \tilde{\pi}.
                \]
            </p>
            <p>
                <strong>Example:</strong> the teapots are both transformed by \[
                A = \begin{bmatrix}
                0.5 & 0 & 1 & 0 \\
                0 & 1.25 & 0 & 0 \\
                0 & 0 & 0.75 & 0 \\
                0 & 0 & 0 & 1
                \end{bmatrix},
                \]
                but the upper one has its normals transformed correctly by \((A^T)^{-1}\),
                while the lower one has its normals transformed incorrectly by \(A\),
                resulting in lighting artifacts (as light reflecting off the object is computed using surface normals).
            </p>
            <!--
            <p>
                <strong>Remark:</strong> Somethimes the notation \(A^{-T}\) is used, as \[
                (A^T)^{-1} = (A^T)^{-1} (A^{-1} A)^T = (A^T)^{-1} A^T (A^{-1})^T = (A^{-1})^T.
                \]
            </p>
            -->
            <script>
             d[8] = (c, e) => {
                 let s = teapotScene(c, e);
                 let m = new BABYLON.StandardMaterial('m', s);
                 m.diffuseColor = BLUE;
                 m.specularColor = RED;
                 m.backFaceCulling = false;
                 var l2 = new BABYLON.DirectionalLight("l2", new BABYLON.Vector3(1, 0, 3), s);
                 let t1, t2;
                 let normals;
                 s.registerBeforeRender(() => {
                     t1 = s.getMeshByName('teapot');
                     if (t1 && !t2) {
                         t1.material = m;
                         t2 = t1.clone();
                         t2.makeGeometryUnique();
                         t1.position.y = -3.2;
                         // t1.position.z = -2;
                         t1.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.PositionKind, true);
                         t1.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.NormalKind, true);
                         t2.position.y = 1.2;
                         // t2.position.z = 2;
                         t2.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.PositionKind, true);
                         t2.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.NormalKind, true);

                         A = BABYLON.Matrix.FromValues(
                             0.5, 0, 1, 0,
                             0, 1.25, 0, 0,
                             0, 0, 0.75, 0,
                             0, 0, 0, 1
                         ).transpose();
                         transformBadNormals(t1, A);
                         transformGoodNormals(t2, A);
                     }
                     if (t1 && t2) {
                         t1.rotation.y = time();
                         t2.rotation.y = time();
                     }
                 });
                 return s;
             };
            </script>
            <!--
            <script>
             d[6] = (c, e) => {
                 let s = teapotScene(c, e);
                 let camera = s.getCameraByName('camera');
                 camera.alpha = Math.PI / 5;
                 const material = new BABYLON.StandardMaterial('material', s);
                 material.alpha = 0.6;
                 material.backFaceCulling = false;
                 material.wireframe = true;
                 let proj = null;
                 s.registerBeforeRender(() => {
                     // camera.alpha = time();
                     let m = s.getMeshByName('teapot');
                     if (m) {
                         m.material = material;
                         m.position.z = -5;
                         m.rotation.y = time();
                         let path = projectMesh(m);
                         if (!proj) {
                             proj = new BABYLON.MeshBuilder.CreateLines('proj', {points: path, updatable: true}, s);
                             proj.color = RED;
                         } else {
                             proj = new BABYLON.MeshBuilder.CreateLines('proj', {points: path, instance: proj}, s);
                         }
                     }
                 });
                 return s;
             };
            </script>
            -->
        </section>
        <section class="slide">
            <h2>Representing planes in 3D, continued</h2>
            <p>
                We know that a plane in 3D is characterized by three points.
                To find the plane which contains three given points \(p\), \(q\) and \(r\) we need to find a solution \(\tilde{\pi}\) to the system \[
                \begin{cases}
                \tilde{p} \cdot \tilde{\pi} = 0, \\
                \tilde{q} \cdot \tilde{\pi} = 0, \\
                \tilde{r} \cdot \tilde{\pi} = 0,
                \end{cases}
                \] which is equvalent to \[
                \underbrace{\begin{bmatrix}
                - & \tilde{p}^T & - \\
                - & \tilde{q}^T & - \\
                - & \tilde{r}^T & -
                \end{bmatrix}}_{= A} \tilde{\pi} = 0,
                \] meaning that \(\tilde{\pi}\) is given by (an arbitrary vector in) the null space of the matrix above.
                If we require that the three points be non-collinear then we have a \(3 \times 4\) matrix with distinct rows, so \(\operatorname{rank} A = 3\),
                and the null space is one-dimensional.
            </p>
            <p>
                Because of duality, we can easily find the (dual coordinates of the) point of intersection of three planes \(\pi\), \(\rho\), and \(\sigma\) in the null space of \[
                B = \begin{bmatrix}
                - & \tilde{\pi}^T & - \\
                - & \tilde{\rho}^T & - \\
                - & \tilde{\sigma}^T & -
                \end{bmatrix}.
                \]
            </p>
        </section>
        <section class="slide">
            <h2>Computing null spaces with SVD</h2>
            <p>
                If we want to actually find the null space in the formulas above, we can use SVD.
                Let \(A = U \Sigma V^T\) where \[
                U \in M_3 \quad \text{and} \quad V = \begin{bmatrix}
                | & | & | & | \\
                v_1 & v_2 & v_3 & v_4 \\
                | & | & | & |
                \end{bmatrix} \in M_4.
                \]
                Since we know that the rank of \(A\) is 3, \[
                \Sigma = \begin{bmatrix}
                \sigma_1 & 0 & 0 & 0 \\
                0 & \sigma_2 & 0 & 0 \\
                0 & 0 & \sigma_3 & 0 \\
                \end{bmatrix},
                \] and therefore \[
                A v_4 = U \Sigma V^T v_4 = U \Sigma V^{-1} v_4 = U \begin{bmatrix}
                \sigma_1 & 0 & 0 & 0 \\
                0 & \sigma_2 & 0 & 0 \\
                0 & 0 & \sigma_3 & 0 \\
                \end{bmatrix} \begin{bmatrix}
                0 \\ 0 \\ 0 \\ 1
                \end{bmatrix} = 0,
                \]
                so the null space of \(A\) is exactly \(\operatorname{span} v_4\),
                and we can take \(\tilde{\pi} = v_4\) to be a representative of the plane.
            </p>
            <p>
                <strong>Note:</strong> another method of computing \(\tilde{\pi}\) is solving the equation (using <em>index set</em> notation), \[
                A[\{1,2,3\},\{1,2,3\}] \underbrace{v}_{3 \times 1} = -A[\{1,2,4\},\{4\}] \quad \text{and setting} \quad \tilde{\pi} = \begin{bmatrix} v \\ 1 \end{bmatrix}.
                \]
            </p>
        </section>
        <section class="slide">
            <h2>Representing lines in 3D</h2>
            <p>
                In 3D lines have more degrees of freedom than a point has.
                Therefore their representation becomes more complicated, and there are various different methods of representing a line,
                one of which is the <em>Pl&uuml;cker matrix</em>.
                To represent a line between \(p\) and \(q\), called the <em>join</em> of the points, the matrix \[
                \tilde{L} = \tilde{p} \tilde{q}^T - \tilde{q} \tilde{p}^T
                \] is used.
                We see that this is an antisymmetric matrix, \[
                \tilde{L}^T = (\tilde{p} \tilde{q}^T)^T - (\tilde{q} \tilde{p}^T)^T = \tilde{q} \tilde{p}^T - \tilde{p} \tilde{q}^T = -\tilde{L},
                \] and that it is indepentent of which representatives of the points are used, \[
                (\lambda \tilde{p}) (\mu \tilde{q})^T - (\mu \tilde{q}) (\lambda \tilde{p})^T
                = \lambda \mu (\tilde{p} \tilde{q}^T - \tilde{q} \tilde{p}^T)
                = \lambda \mu \tilde{L}.
                \]
                The <em>dual Pl&uuml;cker matrix</em> is given by \[
                \tilde{L}^* = \tilde{\pi} \tilde{\rho}^T - \tilde{\rho} \tilde{\pi}^T,
                \] and represents the line given by the intersection of the planes \(\pi\) and \(\rho\), called the <em>meet</em> of the planes.
            </p>
            <p>
                \begin{align}
                p \in L \quad \Longleftrightarrow \quad &\tilde{L}^* \tilde{p} = 0, \\
                L \subset \pi \quad \Longleftrightarrow \quad &\tilde{L} \tilde{\pi} = 0, \\
                \text{the join of } p \text{ and } L \text{ is} \qquad &\tilde{\pi} = \tilde{L}^* \tilde{p}, \\
                \text{the meet of } L \text{ and } \pi \text{ is} \qquad &\tilde{p} = \tilde{L} \tilde{\pi}.
                \end{align}
            </p>
        </section>
        <section class="slide">
            <h2>Pl&uuml;cker lines</h2>
            <p>
                If we study the elements of the Pl&uuml;cker matrix for two points \(p\) and \(q\), we see that they will be on the form \[
                \tilde{L} = \begin{bmatrix}
                p_x \\ p_y \\ p_z \\ 1
                \end{bmatrix} \begin{bmatrix}
                q_x & q_y & q_z & 1
                \end{bmatrix} - \begin{bmatrix}
                q_x \\ q_y \\ q_z \\ 1
                \end{bmatrix} \begin{bmatrix}
                p_x & p_y & p_z & 1
                \end{bmatrix} = \begin{bmatrix}
                0 & n_z & -n_y & v_x \\
                -n_z & 0 & n_x & v_y \\
                n_y & -n_x & 0 & v_z \\
                -v_x & -v_y & -v_z & 0
                \end{bmatrix},
                \] where
                \begin{align}
                n_x &= p_y q_z - p_z q_y, & v_x &= p_x - q_x, \\
                n_y &= p_z q_x - p_x q_z, & v_y &= p_y - q_y, \\
                n_z &= p_x q_y - p_y q_x, & v_z &= p_z - q_z.
                \end{align}
                From this we obtain a more compact representation of a line, the <em>Pl&uuml;cker line</em>, \[
                \mathcal{L} = \begin{bmatrix}
                n \\ v
                \end{bmatrix} \quad \text{where} \quad n = p \times q \quad \text{and} \quad v = p - q.
                \]
                Geometrically, \(n\) is a normal vector to the plane containing the line and the origin, and
                \(v\) is a direction vector of the line.
            </p>
        </section>
        <!--
             <section class="slide">
             <h2>Circles, ellipses, parabolas and hyperbolas</h2>
             <script>
             d[7] = (c, e) => {
             let s = planeScene(c, e);
             let cone = createDoubleCone(3, 3, s);
             let material = new BABYLON.StandardMaterial('material', s);
             material.diffuseColor = RED;
             material.alpha = 0.6;
             cone.material = material;
             cone.material = material;
             let circle = BABYLON.MeshBuilder.CreateLines('circle', {points: ellipsePoints(0.5, 0.5), updatable: true}, s);
             circle.color = GREEN;
             s.registerBeforeRender(() => {
             cone.rotation.x = time() / 2;
             });
             return s;
             }
             </script>
             </section>
        -->
        <section class="slide">
            <h2>Computational advantages of projective geometry</h2>
            <p>
                The extra coordinate means we must store more data, but it allows us to postpone divisions as long as possible,
                as this can be accomplished by simply multiplying the third coordinate.
                This in turn gives improved precision, and it's even possible to use integer arithmetic in many places.
                \[
                \begin{pmatrix}
                3/5 & 4/5 \\
                -4/5 & 3/5
                \end{pmatrix} \begin{pmatrix}
                5/13 \\ 12/13
                \end{pmatrix} = \begin{bmatrix}
                3/5 & 4/5 & 0 \\
                -4/5 & 3/5 & 0 \\
                0 & 0 & 1
                \end{bmatrix} \begin{bmatrix}
                5/13 \\ 12/13 \\ 1
                \end{bmatrix} = \begin{bmatrix}
                3 & 4 & 0 \\
                -4 & 3 & 0 \\
                0 & 0 & 5
                \end{bmatrix} \begin{bmatrix}
                5 \\ 12 \\ 13
                \end{bmatrix} = \begin{bmatrix}
                63 \\ 16 \\ 65
                \end{bmatrix} = \begin{pmatrix}
                63/65 \\ 16/65
                \end{pmatrix}
                \]
            </p>
            <p>
                Similarily, points at infinity allow us to handle special cases without any extra code.
                This also speeds up computation slightly since fewer branches are needed,
                which are one of the more expensive operations for modern computers to handle.
            </p>
        </section>
    </body>
</html>
