<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
	<title>Projective Geometry</title>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script>
	 let d = [];
	 let timeZero;

	 function time() {
	     return (Date.now() - timeZero) / 1000;
         }

         function slideNumber() {
             return parseInt(window.location.hash.split('-')[1]) || 0;
         }

         function updateHash(slides) {
             return (event) => {
                 const margin = 10;
                 for (let k = 0; k < slides.length; k++) {
                     if (window.scrollY > slides[k].offsetTop + margin && (k + 1 >= slides.length || window.scrollY < slides[k + 1].offsetTop - margin)) {
                         if (slideNumber() != k) {
                             window.history.replaceState(null, null, '#slide-' + k);
                         }
                         break;
                     }
                 }
             };
         }

         function initSlides() {
             const slides = document.querySelectorAll('.slide');
             for (let k = 0; k < slides.length; k++) {
                 slides[k].id = 'slide-' + k;
                 const controls = document.createElement('footer');
                 controls.className = 'controls';
                 const back = document.createElement('a');
                 if (k > 0) {
                     back.href = '#slide-' + (k - 1);
                     // back.addEventListener('click', setSlide(k - 1));
                     back.textContent = 'back';
                 }
                 controls.appendChild(back);
                 const number = document.createElement('span');
                 number.textContent = k;
                 controls.appendChild(number);
                 const next = document.createElement('a');
                 if (k < slides.length - 1) {
                     next.href = '#slide-' + (k + 1);
                     // next.addEventListener('click', setSlide(k + 1));
                     next.textContent = 'next';
                 }
                 controls.appendChild(next);
                 slides[k].appendChild(controls);
             }

             window.addEventListener('scroll', updateHash(slides));

             const demos = document.querySelectorAll('.demo');
             for (let k = 0; k < demos.length; k++) {
                 // demos[k].rows = 20;
                 // demos[k].cols = 80;
                 // demos[k].autocomplete = 'off';
                 eval(demos[k].textContent);
             }
         }

         function initScenes(canvas, engine) {
             let scenes = [];
             for (let k = 0; k < d.length; k++) {
                 scenes[k] = d[k] ? d[k](canvas, engine) : null;
             }
             return scenes;
         }

         const RED = new BABYLON.Color3(0.9, 0.1, 0.1);
         const GREEN = new BABYLON.Color3(0.1, 0.9, 0.1);
         const BLUE = new BABYLON.Color3(0.1, 0.1, 0.9);

         function blankScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, 0, 0, BABYLON.Vector3.Zero());
             return scene;
         }

         function loadTeapot(scene, callback) {
             BABYLON.SceneLoader.ImportMesh('', './newell_teaset/', 'teapot.obj', scene, (meshes) => {
                 callback(BABYLON.Mesh.MergeMeshes(meshes));
             });
         }

         function teapotScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             // scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 16, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const material = new BABYLON.StandardMaterial('material', scene);
             material.backFaceCulling = false;
             // material.indexOfRefraction = 2.4;
             // material.specularPower = 0.98;
             // material.diffuseColor = new BABYLON.Color3(0, 0, 0.5); // (0x41 / 0xFF, 0x69 / 0xFF, 0xE1 / 0xFF);
             // = material.specularColor
             // material.ambientColor = material.emissiveColor =
             let teapot = null;
             loadTeapot(scene, t => {
                 t.name = 'teapot';
                 t.material = material;
                 teapot = t;
             });
             return scene;
         }

         function planeScene(canvas, engine) {
             const scene = new BABYLON.Scene();
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 8, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 4});
             plane.rotation.x = Math.PI / 2;
             plane.position.y += 1;
             const transparent = new BABYLON.StandardMaterial('transparent', scene);
             transparent.alpha = 0.6;
             transparent.backFaceCulling = false;
             // transparent.wireframe = true;
             plane.material = transparent;
             const red = new BABYLON.StandardMaterial('red', scene);
             red.diffuseColor = RED;
             const green = new BABYLON.StandardMaterial('green', scene);
             green.diffuseColor = GREEN;
             const blue = new BABYLON.StandardMaterial('blue', scene);
             blue.diffuseColor = BLUE;
             return scene;
         }

         function ellipsePoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a * Math.cos(t);
                 let z = b * Math.sin(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             path.push(path[0]);
             return path;
         }

         function parabolaPoints(a) {
             let path = [];
             for (let t = -100; t < 100; t += 1 / 8) {
                 let x = 2 * a * t;
                 let z = a * t * t;
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function hyperbolaPoints(a, b) {
             let path = [];
             for (let t = 0; t < 2 * Math.PI; t += Math.PI / 8) {
                 let x = a / Math.cos(t);
                 let z = b * Math.tan(t);
                 path.push(new BABYLON.Vector3(x, 1, z));
             }
             return path;
         }

         function createDoubleCone(h, r, s) {
             let cones = [BABYLON.MeshBuilder.CreateCylinder('cone0', {height: h, diameterTop: r, diameterBottom: 0}, s),
                          BABYLON.MeshBuilder.CreateCylinder('cone1', {height: h, diameterTop: r, diameterBottom: 0}, s)];
             cones[0].position.y += h / 2;
             cones[1].position.y -= h / 2;
             cones[1].rotation.x = Math.PI;
             return BABYLON.Mesh.MergeMeshes(cones);
         }

         function projectMesh(mesh) {
             let pos = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
             let matrix = mesh.getWorldMatrix();
             let path = [];
             for (let k = 0; k < pos.length; k += 3) {
                 let vertex = BABYLON.Vector3.TransformCoordinates(new BABYLON.Vector3(pos[k], pos[k + 1], pos[k + 2]), matrix);
                 if (Math.abs(vertex.z) > 0) {
                     // vertex.x *= 3 / Math.abs(vertex.z);
                     // vertex.y *= 3 / Math.abs(vertex.z);
                 }
                 vertex.z = 1;
                 path.push(vertex);
             }
             return path;
         }

         function doRender() {
             canvas = document.getElementById('canvas');
             canvas.height = canvas.width = Math.floor(window.innerWidth / 4);

             const antialias = false;
             engine = new BABYLON.Engine(canvas, antialias);

             const scenes = initScenes(canvas, engine);
             const blank = blankScene(canvas, engine);

             window.addEventListener('resize', () => {
                 engine.resize();
             });

             timeZero = Date.now();
             engine.runRenderLoop(() => {
                 const k = slideNumber();
                 if (scenes[k]) {
                     scenes[k].render();
                 } else {
                     blank.render();
                 }
             });
         }

         function main() {
             initSlides();
             doRender();
         }
         window.addEventListener('load', main);
        </script>
        <style>
         body {
             margin: 0;
             padding: 0;
         }
         #canvas {
             position: fixed;
             right: 5vw;
             top: 10vh;
         }
         .slide {
             width: 60vw;
             height: 90vh;
             position: relative;
             padding: 2.5vw;
         }
         .controls {
             position: absolute;
             bottom: 5vw;
             left: 2.5vw;
             display: flex;
             justify-content: center;
             background-color: grey;
             border-radius: 5px;
         }
         .controls > * {
             flex: 1;
             margin: 1em;
             width: 2em;
             color: inherit;
             text-align: center;
             text-decoration: none;
         }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <section class="slide">
            <h1>Projective Geometry</h1>
            <p>
            </p>
            <pre class="demo">
d[0] = (c, e) => {
    const s = teapotScene(c, e);
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Linear Transformations</h2>
            <p>
                Using matrices we can for example rotate, \[
                B = \begin{pmatrix}
                \cos t & 0 & \sin t \\
                0 & 1 & 0 \\
                -\sin t & 0 & \cos t
                \end{pmatrix}
                \] and scale, \[
                A = \begin{pmatrix}
                0.75 + 0.25 \sin t & 0 & 0 \\
                0 & 0.75 + 0.25 \sin t & 0 \\
                0 & 0 & 0.75 + 0.25 \sin t
                \end{pmatrix}
                \] an object by multiplying each of its vertices with the matrix \(AB\).
            </p>
            <pre class="demo">
d[1] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        A = BABYLON.Matrix.FromValues(
            0.75 + 0.25 * Math.sin(time()), 0, 0, 0,
            0, 0.75 + 0.25 * Math.sin(time()), 0, 0,
            0, 0, 0.75 + 0.25 * Math.sin(time()), 0,
            0, 0, 0, 1
        ).transpose();
        B = BABYLON.Matrix.FromValues(
            Math.cos(time()), 0, Math.sin(time()), 0,
            0, 1, 0, 0,
            -Math.sin(time()), 0, Math.cos(time()), 0,
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(A.multiply(B), false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Affine transformations</h2>
            <p>
                By adding an extra coordinate to the vertices, \[
                p = \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \quad \Longrightarrow \quad \tilde{p} = \begin{bmatrix}
                x \\ y \\ z \\ 1
                \end{bmatrix},
                \] we can also obtain translations, for example by \[
                C = \begin{bmatrix}
                1 & 0 & 0 & 2 \cos t \\
                1 & 0 & 0 & 0 \\
                1 & 0 & 0 & 2 \sin t \\
                0 & 0 & 0 & 1
                \end{bmatrix}.
                \]
                How can we interpret this association of \(p\) with \(\tilde{p}\) geometrically?
            </p>
            <pre class="demo">
d[2] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        C = BABYLON.Matrix.FromValues(
            1, 0, 0, 2 * Math.cos(time()),
            0, 1, 0, 0,
            0, 0, 1, 2 * Math.sin(time()),
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(C, false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Homogeneous coordinates</h2>
            <p>
                We identify a line on the form \[
                \tilde{p} = \left\{ \begin{pmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{pmatrix} : \lambda \in \mathbf{R} \right\},
                \] with any representative \[
                \tilde{p} = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \quad \text{for a fixed } \lambda \neq 0.
                \]
            </p>
            <p>
                These representatives are called the <em>homogeneous coordinates</em> of the point \[
                p = \begin{pmatrix}
                x \\ y
                \end{pmatrix}
                \] in the two dimensional plane.
                Each 2D point is thus represented by a one-dimensional subspace (a line) in 3D.
                In a similar manner, each 3D point can be represented by a one-dimensional subspace of 4D space.
            </p>
            <script>
             d[3] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 s.registerBeforeRender(() => {
                     p.position.x = 2 * Math.cos(time() / 2);
                     p.position.y = 1;
                     p.position.z = Math.sin(time() / 2);
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Points at infinity</h2>
            <p>
                We see that the 2D point \(p\) is given by the intersection between \(\tilde{p}\) and the plane parallel
                to the \(xy\) plane with \(z = 1\), called the <em>viewing plane</em>.
                What happens for \[
                \tilde{p} = \begin{bmatrix}
                \lambda x \\ \lambda y \\ 0
                \end{bmatrix}?
                \]
                These lines can be seen as representing <em>points at infinity</em>, in the direction given by \(x\) and \(y\).
            </p>
            <p>
                In one dimension there is only one point at infinity, commonly denoted \(\infty\).
                In two dimensions there is <em>line at infinity</em> and in three dimensions a <em>plane at infinity</em>.
            </p>
            <script>
             d[4] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [new BABYLON.Vector3(0, 0, -1.5), new BABYLON.Vector3(0, 0, 1.5)]}, s);
                 // m.color = RED;
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = 1 / (1 - Math.abs(Math.sin(time())));
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.normalizeToNew().scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representation of lines in 2D</h2>
            <p>
                This representation of points in 2D also gives a simple representation of lines in 2D:
                The line containing points with homogeneous coordinates \(\tilde{p}\) and \(\tilde{q}\) is has homogeneous coordinates given by the two-dimensional subspace \(\tilde{l}\),
                containing both \(\tilde{p}\) and \(\tilde{q}\).
            </p>
            <p>
                The normal vector of this plane in 3D is easily computed as the scalar product \[
                \tilde{p} \times \tilde{q} = \begin{bmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{bmatrix} \times \begin{bmatrix}
                \mu z \\ \mu w \\ \mu
                \end{bmatrix} = \begin{bmatrix}
                \lambda \mu (y-w) \\
                \lambda \mu (z-x) \\
                \lambda \mu (xw-yz)
                \end{bmatrix} = \tilde{l},
                \] where we identify any normal vector of the plane with the plane itself.
            </p>
            <p>
                Finding the point where two lines \(l\) and \(m\) intersect simply amounts to finding the intersection between the planes \(\tilde{l}\) and \(\tilde{m}\),
                which can be done with the cross product of the normal vectors, \[
                \tilde{p} = \tilde{l} \times \tilde{m}.
                \]
                The fact that points and lines are essentially interchangeable in 2D is called <em>duality</em>.
            </p>
            <p>
                What happens if the two lines are parallel? For example, consider \[
                \tilde{l} = \begin{bmatrix}
                1 \\ 2 \\ 3
                \end{bmatrix} \quad \text{and} \quad \tilde{m} = \begin{bmatrix}
                1 \\ 2 \\ 5
                \end{bmatrix} \quad \Longrightarrow \quad \tilde{p} = \tilde{l} \times \tilde{m} = \begin{bmatrix}
                4 \\ -2 \\ 0
                \end{bmatrix}.
                \]
                In the interpretation of projective geometry, \(l\) and \(m\) meet some point at infinity \(p\).
                In fact, any line parallel to \(l\) will meet it at \(p\).
            </p>
            <p>
                What if the lines are coincident (i.e. the same line)?
                Then the cross product of the homogeneous coordinates is zero.
                The converse is also true.
            </p>
            <script>
             d[5] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('green');
                 let q = BABYLON.MeshBuilder.CreateSphere('q', {diameter: 0.2}, s);
                 q.material = s.getMaterialByName('blue');
                 q.position.x = 1.5;
                 q.position.y = 1;
                 q.position.z = 1;
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 l.color = GREEN;
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 let n = BABYLON.MeshBuilder.CreateLines('n', {points: [q.position.scale(-0.5), q.position.scale(1.5)]}, s);
                 n.color = BLUE;
                 // let plane = BABYLON.MeshBuilder.CreatePlane('plane', {size: 3});
                 // plane.rotation.x = Math.PI / 2;
                 // plane.position.z += 1;
                 // plane.material = s.getMaterialByName('transparent');
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = Math.sin(time());
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-0.5), p.position.scale(1.5)], instance: l}, s);
                     let d = q.position.subtract(p.position).scale(0.5);
                     m = BABYLON.MeshBuilder.CreateLines('m', {points: [p.position.subtract(d), q.position.add(d)], instance: m}, s);
                     /* let normal = p.position.cross(q.position);
                        let T = BABYLON.Matrix.FromValues(
                        q.position.x, normal.x, p.position.x, 0,
                        q.position.y, normal.y, p.position.y, 0,
                        q.position.z, normal.z, p.position.z, 0,
                        0, 0, 0, 1
                        ).transpose();
                        plane.setPivotMatrix(T, false); */
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representing planes in 3D</h2>
            <p>
                The situation with points and lines in 2D is analogous to points and planes in 3D, as both objects have three degrees of freedom.
                The Cartesian equation for the plane is \[
                \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \in \pi \quad \Longleftrightarrow \quad \begin{pmatrix}
                a \\ b \\ c
                \end{pmatrix} \cdot \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} = d,
                \] where \(\begin{pmatrix} a & b & c \end{pmatrix}^T\) is a normal vector and \(d\) a constand determining "how far the plane is from the origin".
            </p>
            <p>
                In homogeneous coordinates this can be expressed as \begin{equation}
                \tag{*} \label{star}
                p \in \pi \quad \Longleftrightarrow \quad \tilde{p} \cdot \tilde{\pi} = 0.
                \end{equation}
            </p>
            <p>
                Problem: when applying an affine transformation \(A\) to the space, planes are not transformed as expected.
                The same is true for lines in 2D.
                Let \(\tilde{p}' = A \tilde{p}\) and \(\tilde{\pi}' = A \tilde{\pi}\). Then the equation becomes \[
                0 = \tilde{p}' \cdot \tilde{\pi}' = (A \tilde{p}) \cdot (A \tilde{\pi}) = (A \tilde{p})^T (A \tilde{\pi}) = \tilde{p} A^T A \tilde{\pi},
                \] but this is not the same as \eqref{star}!
                The solution is to transform planes by the inverse of the transpose of \(A\), so that \(\tilde{\pi}' = (A^T)^{-1}\), and the equation becomes \[
                0 = \tilde{p}' \cdot \tilde{\pi}'
                = (A \tilde{p}) \cdot ((A^T)^{-1} \tilde{\pi})
                = (A \tilde{p})^T ((A^T)^{-1} \tilde{\pi})
                = \tilde{p} A^T (A^T)^{-1} \tilde{\pi}
                = \tilde{p} \cdot \tilde{\pi}.
                \]
                This also applies when transforming lines in 2D, as both \(\tilde{l}\) and \(\tilde{\pi}\) are essentially normal vectors of the line or plane they represent.
            </p>
            <!--
            <script class="demo">
             d[6] = (c, e) => {
                 let s = teapotScene(c, e);
                 let camera = s.getCameraByName('camera');
                 camera.alpha = Math.PI / 5;
                 const material = new BABYLON.StandardMaterial('material', s);
                 material.alpha = 0.6;
                 material.backFaceCulling = false;
                 material.wireframe = true;
                 let proj = null;
                 s.registerBeforeRender(() => {
                     // camera.alpha = time();
                     let m = s.getMeshByName('teapot');
                     if (m) {
                         m.material = material;
                         m.position.z = -5;
                         m.rotation.y = time();
                         let path = projectMesh(m);
                         if (!proj) {
                             proj = new BABYLON.MeshBuilder.CreateLines('proj', {points: path, updatable: true}, s);
                             proj.color = RED;
                         } else {
                             proj = new BABYLON.MeshBuilder.CreateLines('proj', {points: path, instance: proj}, s);
                         }
                     }
                 });
                 return s;
             };
            </script>
            -->
        </section>
        <section class="slide">
            <h2>Representing planes in 3D, continued</h2>
            <p>
                We know that a plane in 3D is characterized by three points.
                To find the plane which contains three given points \(p\), \(q\) and \(r\) we need to find a solution \(\tilde{\pi}\) to the system \[
                \begin{cases}
                \tilde{p} \cdot \tilde{\pi} = 0, \\
                \tilde{q} \cdot \tilde{\pi} = 0, \\
                \tilde{r} \cdot \tilde{\pi} = 0,
                \end{cases}
                \] which is equvalent to \[
                \underbrace{\begin{bmatrix}
                - & \tilde{p}^T & - \\
                - & \tilde{q}^T & - \\
                - & \tilde{r}^T & -
                \end{bmatrix}}_{= A} \tilde{\pi} = 0,
                \] meaning that \(\tilde{\pi}\) is given by (an arbitrary vector in) the null space of the matrix above.
                If we require that the three points be non-collinear then we have a \(3 \times 4\) matrix with distinct rows, so \(\operatorname{rank} A = 3\),
                and the null space is one-dimensional.
            </p>
            <p>
                Because of duality, we can easily find the (dual coordinates of the) point of intersection of three planes \(\pi\), \(\rho\), and \(\sigma\) in the null space of \[
                B = \begin{bmatrix}
                - & \tilde{\pi}^T & - \\
                - & \tilde{\rho}^T & - \\
                - & \tilde{\sigma}^T & -
                \end{bmatrix}.
                \]
            </p>
        </section>
        <section class="slide">
            <h2>Computing null spaces with SVD</h2>
            <p>
                If we want to actually find the null space in the formulas above, we can use SVD.
                Let \(A = U \Sigma V^T\) where \[
                U \in M_3 \quad \text{and} \quad V = \begin{bmatrix}
                | & | & | & | \\
                v_1 & v_2 & v_3 & v_4 \\
                | & | & | & |
                \end{bmatrix} \in M_4.
                \]
                Since we know that the rank of \(A\) is 3, \[
                \Sigma = \begin{bmatrix}
                \sigma_1 & 0 & 0 & 0 \\
                0 & \sigma_2 & 0 & 0 \\
                0 & 0 & \sigma_3 & 0 \\
                \end{bmatrix},
                \] and therefore \[
                A v_4 = U \Sigma V^T v_4 = U \Sigma V^{-1} v_4 = U \begin{bmatrix}
                \sigma_1 & 0 & 0 & 0 \\
                0 & \sigma_2 & 0 & 0 \\
                0 & 0 & \sigma_3 & 0 \\
                \end{bmatrix} \begin{bmatrix}
                0 \\ 0 \\ 0 \\ 1
                \end{bmatrix} = 0,
                \]
                so the null space of \(A\) is exactly \(\operatorname{span} v_4\),
                and we can take \(\tilde{\pi} = v_4\) to be a representative of the plane.
            </p>
            <p>
                Note: another method of computing \(\tilde{\pi}\) is solving the equation (using <em>index set</em> notation), \[
                A[\{1,\dots,4\},\{1,2,3\}] v = -A[\{1,\dots,4\},\{4\}],
                \] and setting \(\tilde{\pi} = \begin{bmatrix} v \\ 1 \end{bmatrix}\).
            </p>
        </section>
        <section class="slide">
            <h2>Representing lines in 3D</h2>
            <p>
                In 3D lines have more degrees of freedom than a point has.
                Therefore their representation becomes more complicated, and there are various different methods of representing a line,
                one of which is the <em>Pl&uuml;cker matrix</em>.
                To represent a line between \(p\) and \(q\), called the <em>join</em> of the points, the matrix \[
                \tilde{L} = \tilde{p} \tilde{q}^T - \tilde{q} \tilde{p}^T
                \] is used.
                We see that this is an antisymmetric matrix, \[
                \tilde{L}^T = (\tilde{p} \tilde{q}^T)^T - (\tilde{q} \tilde{p}^T)^T = \tilde{q} \tilde{p}^T - \tilde{p} \tilde{q}^T = -\tilde{L},
                \] and that it is indepentent of which representatives of the points are used, \[
                (\lambda \tilde{p}) (\mu \tilde{q})^T - (\mu \tilde{q}) (\lambda \tilde{p})^T
                = \lambda \mu (\tilde{p} \tilde{q}^T - \tilde{q} \tilde{p}^T)
                = \lambda \mu \tilde{L}.
                \]
                The <em>dual Pl&uuml;cker matrix</em> is given by \[
                \tilde{L}^* = \tilde{\pi} \tilde{\rho}^T - \tilde{\rho} \tilde{\pi}^T,
                \] and represents the line given by the intersection of the planes \(\pi\) and \(\rho\), called the <em>meet</em> of the planes.
            </p>
            <p>
                This representation gives a number of nice formulas:
                \begin{align}
                p \in L \quad \Longleftrightarrow \quad &\tilde{L}^* \tilde{p} = 0, \\
                L \subset \pi \quad \Longleftrightarrow \quad &\tilde{L} \tilde{\pi} = 0, \\
                \text{the join of } p \text{ and } L \text{ is} \qquad &\tilde{\pi} = \tilde{L}^* \tilde{p}, \\
                \text{the meet of } L \text{ and } \pi \text{ is} \qquad &\tilde{p} = \tilde{L} \tilde{\pi}.
                \end{align}
            </p>
        </section>
        <section class="slide">
            <h2>Pl&uuml;cker lines</h2>
            <p>
                If we study the elements of the Pl&uuml;cker matrix for two points \(p\) and \(q\), we see that they will be on the form \[
                \tilde{L} = \begin{bmatrix}
                p_x & p_y & p_z & 1
                \end{bmatrix} \begin{bmatrix}
                q_x \\ q_y \\ q_z \\ 1
                \end{bmatrix} - \begin{bmatrix}
                q_x & q_y & q_z & 1
                \end{bmatrix} \begin{bmatrix}
                p_x \\ p_y \\ p_z \\ 1
                \end{bmatrix} = \begin{bmatrix}
                0 & -n_x & n_y & v_x \\
                n_x & 0 & -n_z & v_y \\
                -n_y & n_z & 0 & v_z \\
                -v_x & -v_y & -v_z & 0
                \end{bmatrix},
                \] where
                \begin{align}
                n_x &= p_y q_z - p_z q_y, & v_x &= p_x - q_x, \\
                n_y &= p_z q_x - p_x q_z, & v_y &= p_y - q_y, \\
                n_z &= p_x q_y - p_y q_x, & v_z &= p_z - q_z.
                \end{align}
                From this we obtain a more compact representation of a line, the <em>Pl&uuml;cker line</em>, \[
                \mathcal{L} = \begin{bmatrix}
                n \\ v
                \end{bmatrix} \quad \text{where} \quad n = p \times q \quad \text{and} \quad v = p - q.
                \]
                Geometrically, \(n\) is a normal vector to the plane containing the line and the origin, and
                \(v\) is a direction vector of the line.
            </p>
        </section>
        <!--
        <section class="slide">
            <h2>Circles, ellipses, parabolas and hyperbolas</h2>
            <script>
             d[7] = (c, e) => {
                 let s = planeScene(c, e);
                 let cone = createDoubleCone(3, 3, s);
                 let material = new BABYLON.StandardMaterial('material', s);
                 material.diffuseColor = RED;
                 material.alpha = 0.6;
                 cone.material = material;
                 cone.material = material;
                 let circle = BABYLON.MeshBuilder.CreateLines('circle', {points: ellipsePoints(0.5, 0.5), updatable: true}, s);
                 circle.color = GREEN;
                 s.registerBeforeRender(() => {
                     cone.rotation.x = time() / 2;
                 });
                 return s;
             }
            </script>
        </section>
        -->
        <section class="slide">
            <h2>Computational advantages of projective geometry</h2>
            <p>
                The extra coordinate means we must store more data, but it allows us to postpone divisions as long as possible,
                as this can be accomplished by simply multiplying the third coordinate.
                This in turn gives improved precision, and it's even possible to use integer arithmetic in many places.
                \[
                \begin{pmatrix}
                3/5 & 4/5 \\
                -4/5 & 3/5
                \end{pmatrix} \begin{pmatrix}
                5/13 \\ 12/13
                \end{pmatrix} = \begin{bmatrix}
                3/5 & 4/5 & 0 \\
                -4/5 & 3/5 & 0 \\
                0 & 0 & 1
                \end{bmatrix} \begin{bmatrix}
                5/13 \\ 12/13 \\ 1
                \end{bmatrix} = \begin{bmatrix}
                3 & 4 & 0 \\
                -4 & 3 & 0 \\
                0 & 0 & 5
                \end{bmatrix} \begin{bmatrix}
                5 \\ 12 \\ 13
                \end{bmatrix} = \begin{bmatrix}
                63 \\ 16 \\ 65
                \end{bmatrix} = \begin{pmatrix}
                63/65 \\ 16/65
                \end{pmatrix}
                \]
            </p>
            <p>
                Similarily, points at infinity allow us to handle special cases without any extra code.
                This also speeds up computation slightly since less branches are needed, which is one of the more expensive operations in modern computers.
            </p>
        </section>
    </body>
</html>
