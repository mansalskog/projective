<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
	<title>Projective Geometry</title>
	<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
	<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
	<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.js"></script>
	<script>
	 let d = [];
	 let timeZero;

	 function time() {
	     return (Date.now() - timeZero) / 1000;
         }

         function initSlides() {
             const slides = document.querySelectorAll('.slide');
             for (let k = 0; k < slides.length; k++) {
                 slides[k].id = 'slide-' + k;
                 const controls = document.createElement('footer');
                 controls.className = 'controls';
                 const back = document.createElement('a');
                 if (k > 0) {
                     back.href = '#slide-' + (k - 1);
                     // back.addEventListener('click', setSlide(k - 1));
                     back.textContent = 'back';
                 }
                 controls.appendChild(back);
                 const next = document.createElement('a');
                 if (k < slides.length - 1) {
                     next.href = '#slide-' + (k + 1);
                     // next.addEventListener('click', setSlide(k + 1));
                     next.textContent = 'next';
                 }
                 controls.appendChild(next);
                 slides[k].appendChild(controls);
             }

             const demos = document.querySelectorAll('.demo');
             for (let k = 0; k < demos.length; k++) {
                 // demos[k].rows = 20;
                 // demos[k].cols = 80;
                 // demos[k].autocomplete = 'off';
                 eval(demos[k].textContent);
             }
         }

         function initScenes(canvas, engine) {
             let scenes = [];
             for (let k = 0; k < d.length; k++) {
                 scenes[k] = d[k] ? d[k](canvas, engine) : null;
             }
             return scenes;
         }

         function blankScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, 0, 0, BABYLON.Vector3.Zero());
             return scene;
         }

         function teapotScene(canvas, engine) {
             const scene = new BABYLON.Scene(engine);
             // scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 16, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const material = new BABYLON.StandardMaterial('material', scene);
             material.backFaceCulling = false;
             // material.indexOfRefraction = 2.4;
             // material.specularPower = 0.98;
             // material.diffuseColor = new BABYLON.Color3(0, 0, 0.5); // (0x41 / 0xFF, 0x69 / 0xFF, 0xE1 / 0xFF);
             // = material.specularColor
             // material.ambientColor = material.emissiveColor =
             let teapot = null;
             BABYLON.SceneLoader.ImportMesh('', './newell_teaset/', 'teapot.obj', scene, (meshes) => {
                 teapot = BABYLON.Mesh.MergeMeshes(meshes);
                 teapot.name = 'teapot';
                 teapot.material = material;
             });
             return scene;
         }

         function planeScene(canvas, engine) {
             const scene = new BABYLON.Scene();
             const camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 8, BABYLON.Vector3.Zero(), scene);
             const l = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);
             l.intensity = 0.7;
             const transparent = new BABYLON.StandardMaterial('transparent', scene);
             transparent.alpha = 0.6;
             transparent.wireframe = true;
             const plane = BABYLON.MeshBuilder.CreateGround('plane', {width: 4, height: 4}, scene);
             plane.position.y += 1;
             plane.material = transparent;
             const red = new BABYLON.StandardMaterial('red', scene);
             red.diffuseColor = new BABYLON.Color3(0.9, 0.1, 0.1);
             const green = new BABYLON.StandardMaterial('green', scene);
             green.diffuseColor = new BABYLON.Color3(0.1, 0.9, 0.1);
             const blue = new BABYLON.StandardMaterial('blue', scene);
             blue.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.9);
             return scene;
         }

         function doRender() {
             canvas = document.getElementById('canvas');
             canvas.height = canvas.width = Math.floor(window.innerWidth / 4);

             const antialias = false;
             engine = new BABYLON.Engine(canvas, antialias);

             const scenes = initScenes(canvas, engine);
             const blank = blankScene(canvas, engine);

             window.addEventListener('resize', () => {
                 engine.resize();
             });

             timeZero = Date.now();
             engine.runRenderLoop(() => {
                 const k = parseInt(window.location.hash.split('-')[1]);
                 if (!isNaN(k) && scenes[k]) {
                     scenes[k].render();
                 } else {
                     blank.render();
                 }
             });
         }

         function main() {
             initSlides();
             doRender();
         }
         window.addEventListener('load', main);
        </script>
        <style>
         body {
             margin: 0;
             padding: 0;
         }
         #canvas {
             position: fixed;
             right: 5vw;
             top: 10vh;
         }
         .slide {
             width: 60vw;
             height: 90vh;
             position: relative;
             padding: 2.5vw;
         }
         .controls {
             position: absolute;
             bottom: 5vw;
             left: 2.5vw;
             display: flex;
             justify-content: center;
             background-color: grey;
             border-radius: 5px;
         }
         .controls > a {
             flex: 1;
             margin: 1em;
             width: 2em;
             color: inherit;
             text-decoration: none;
         }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <section class="slide">
            <h1>Projective Geometry</h1>
            <p>
            </p>
            <pre class="demo">
d[0] = (c, e) => {
    const s = teapotScene(c, e);
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Linear Transformations</h2>
            <p>
                Using matrices we can for example scale, \[
                A = \begin{pmatrix}
                0 & 0 & 0 \\
                0 & 0.75 + 0.25 \sin t & 0 \\
                0 & 0 & 0
                \end{pmatrix}
                \] and rotate, \[
                B = \begin{pmatrix}
                \cos t & 0 & \sin t \\
                0 & 1 & 0 \\
                -\sin t & 0 & \cos t
                \end{pmatrix}
                \] an object by multiplying each of its vertices with the matrix \(AB\).
            </p>
            <pre class="demo">
d[1] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        A = BABYLON.Matrix.FromValues(
            1, 0, 0, 0,
            0, 0.75 + 0.25 * Math.sin(time()), 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        ).transpose();
        B = BABYLON.Matrix.FromValues(
            Math.cos(time()), 0, Math.sin(time()), 0,
            0, 1, 0, 0,
            -Math.sin(time()), 0, Math.cos(time()), 0,
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(A.multiply(B), false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Affine transformations</h2>
            <p>
                By adding an extra coordinate to the vertices, \[
                p = \begin{pmatrix}
                x \\ y \\ z
                \end{pmatrix} \quad \Longrightarrow \quad p_H = \begin{pmatrix}
                x \\ y \\ z \\ 1
                \end{pmatrix},
                \] we can also obtain translations, for example \[
                C = \begin{pmatrix}
                1 & 0 & 0 & 2 \cos t \\
                1 & 0 & 0 & 0 \\
                1 & 0 & 0 & 2 \sin t \\
                0 & 0 & 0 & 1
                \end{pmatrix}.
                \]
                How can we interpret this association of \(p\) with \(p_H\) geometrically?
            </p>
            <pre class="demo">
d[2] = (c, e) => {
    let s = teapotScene(c, e);
    s.registerBeforeRender(() => {
        C = BABYLON.Matrix.FromValues(
            1, 0, 0, 2 * Math.cos(time()),
            0, 1, 0, 0,
            0, 0, 1, 2 * Math.sin(time()),
            0, 0, 0, 1
        ).transpose();
        let m = s.getMeshByName('teapot');
        if (m) {
            m.setPivotMatrix(C, false);
        }
    });
    return s;
};
            </pre>
        </section>
        <section class="slide">
            <h2>Homogeneous coordinates</h2>
            <p>
                Vectors on the form \[
                p_H = \begin{pmatrix}
                \lambda x \\ \lambda y \\ \lambda
                \end{pmatrix},
                \] where \(\lambda \neq 0\), are said to be the <em>homogeneous coordinates</em> of the point \[
                p = \begin{pmatrix}
                x \\ y
                \end{pmatrix},
                \] in the two dimensional plane.
                Each 2D point is thus represented by a one-dimensional subspace (a line) in 3D.
                In a similar manner, each 3D point can be represented by a one-dimensional subspace of 4D space.
            </p>
            <script>
             d[3] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('blue');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 s.registerBeforeRender(() => {
                     p.position.x = 2 * Math.cos(time() / 2);
                     p.position.y = 1;
                     p.position.z = Math.sin(time() / 2);
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-10), p.position.scale(10)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Homogeneous coordinates</h2>
            <p>
                We see that the 2D point \(p\) is given by the intersection between \(p_H\) and the plane \[
                p_H \cdot \begin{pmatrix} 0 & 0 & 1 \end{pmatrix} = 1,
                \] but what happends for \[
                p_H = \begin{pmatrix}
                \lambda x \\ \lambda y \\ 0
                \end{pmatrix}?
                \]
                These lines can be seen as representing <em>points at infinity</em>, in the direction given by \(x\) and \(y\).
            </p>
            <script>
             d[4] = (c, e) => {
                 let s = planeScene(c, e);
                 let o = BABYLON.MeshBuilder.CreateSphere('o', {diameter: 0.2}, s);
                 o.material = s.getMaterialByName('red');
                 let p = BABYLON.MeshBuilder.CreateSphere('p', {diameter: 0.2}, s);
                 p.material = s.getMaterialByName('blue');
                 let l = BABYLON.MeshBuilder.CreateLines('l', {points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], updatable: true}, s);
                 let m = BABYLON.MeshBuilder.CreateLines('m', {points: [new BABYLON.Vector3(0, 0, -1000), new BABYLON.Vector3(0, 0, 100)]}, s);
                 s.registerBeforeRender(() => {
                     p.position.x = -1;
                     p.position.y = 1;
                     p.position.z = 1 / (1 - Math.abs(Math.sin(time())));
                     l = BABYLON.MeshBuilder.CreateLines('l', {points: [p.position.scale(-10), p.position.scale(10)], instance: l}, s);
                 });
                 return s;
             };
            </script>
        </section>
        <section class="slide">
            <h2>Representation of lines and planes</h2>
            <p>
                This representation of points in 2D also gives a simple representation of lines in 2D:
                The line containing points (represented by) \(p_H\) and \(q_H\) is represented by the two-dimensional subspace \(l_H\) containing both \(p_H\) and \(q_H\).
                The normal vector of this plane in 3D is easily computed as the scalar product \[
                p_H \times q_H
                \]
            </p>
        </section>
    </body>
</html>
